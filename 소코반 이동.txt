
void inputkey(char input_char) //키보드입력
{
   int move(int a, int u)//'창고지기'의 움직임 + Undo배열에 움직이 모습 저장
   {
   u++;
   int x = check_x(n);
   int y = check_y(n);
   int o;
   
   switch (input_char)
   case 'h': // 위; 좌표 감소

      if (map[n][x][y-1] == 36) // $
      {
         if(map[n][x][y-2] == 32 || map[n][x][y-2] == 79)
            // 상자 옆이 빈공간
         {
          if(Floor[n][x][y])
             map[n][x][y] = 79;
          else
             map[n][x][y] = 32;
          map[n][x][y-2] = 36;
          map[n][x][y-1] = 64;
          break;
         }
         else
            break;
      }

      else if (map[n][x][y-1] == 32) // sp(빈 공간)
      {
         if(Floor[n][x][y]) // 1일 경우 O바닥 // 0일 경우 맨바닥
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x][y-1] = 64;
         break;
      }
      else if (map[n][x][y-1] == 79)
      {
         if(Floor[n][x][y])
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x][y-1] = 64;
         break;
      }
      else
         break;
   
   case 'j': // 아래; 좌표 증가

      if (map[n][x+1][y] == 36) // $
      {
         if(map[n][x+2][y] == 32 || map[n][x+2][y] == 79)
            // 상자 옆이 빈공간
         {
          if(Floor[n][x][y])
             map[n][x][y] = 79;
          else
             map[n][x][y] = 32;
          map[n][x+2][y] = 36;
          map[n][x+1][y] = 64;
          break;
         }
         else
            break;
      }

      else if (map[n][x+1][y] == 32) // sp(빈 공간)
      {
         if(Floor[n][x][y]) // 1일 경우 O바닥 // 0일 경우 맨바닥
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x+1][y] = 64;
         break;
      }
      else if (map[n][x+1][y] == 79)
      {
         if(Floor[n][x][y])
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x+1][y] = 64;
         break;
      }
      else
         break;
	 
   case 'k': // 위; 좌표 감소

      if (map[n][x-1][y] == 36) // $
      {
         if(map[n][x-2][y] == 32 || map[n][x-2][y] == 79)
            // 상자 옆이 빈공간
         {
          if(Floor[n][x][y])
             map[n][x][y] = 79;
          else
             map[n][x][y] = 32;
          map[n][x-2][y] = 36;
          map[n][x-1][y] = 64;
          break;
         }
         else
            break;
      }

      else if (map[n][x-1][y] == 32) // sp(빈 공간)
      {
         if(Floor[n][x][y]) // 1일 경우 O바닥 // 0일 경우 맨바닥
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x-1][y] = 64;
         break;
      }
      else if (map[n][x-1][y] == 79)
      {
         if(Floor[n][x][y])
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x-1][y] = 64;
         break;
      }
      else
         break;
	 	 
   case 'l':

      if (map[n][x][y+1] == 36) // $
      {
         if(map[n][x][y+2] == 32 || map[n][x][y+2] == 79)
            // 상자 옆이 빈공간
         {
          if(Floor[n][x][y])

             map[n][x][y] = 79;
          else
             map[n][x][y] = 32;
          map[n][x][y+2] = 36;
          map[n][x][y+1] = 64;
          break;
         }
         else
            break;
      }

      else if (map[n][x][y+1] == 32) // sp(빈 공간)
      {
         if(Floor[n][x][y]) // 1일 경우 O바닥 // 0일 경우 맨바닥
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x][y+1] = 64;
         break;
      }
      else if (map[n][x][y+1] == 79)
      {
         if(Floor[n][x][y])
            map[n][x][y] = 79;
         else
            map[n][x][y] = 32;

         map[n][x][y+1] = 64;
         break;
      }
      else
      	break;
      }
      for(int i =1;i<size[n];i++){
      	for(int j = 0; j<30; j++){
      		if(u == 7)
      		u = 1;
      		Undo[u][n][i][j] = map[n][i][j];
      	}
      }
      
       f = finish();
       return u;
       }
	int undo(int u) // 'u' 명령어 함수
	{
     	u--;
     	if( u > 0 ){
     	for(int i=1;i<size[n];i++){
          for(int j=0;j<30;j++){
          map[n][i][j] = Undo[u][n][i][j];
     	     }
     	}
     	}
     	else{
     	u = 6;
     	for(int i=1;i<size[n];i++){
          for(int j=0;j<30;j++){
          map[n][i][j] = Undo[u][n][i][j];
          }
     	}
     	}
	 
   case 'u':
	cnt++;
	break;
   void replay() // 'r'명령어, Undo[0]는 map.txt에 있는 맵  상태
 {
     system("clear");
     for(int i =1; i < size[n]; i++)
          for(int j=0 ; j<30; j++)
          map[n][i][j] = Undo[0][n][i][j];
  }
   case 'n':
	
	break;
   case 'e':
	
	break;
 
	void save() // 's'명령어 , 시간과 맵상황을 저장해서 sokoban.txt 파일에 저장, 뭐 더 save 할게 있으면 추가하고
	{
	FILE *out;
	out = fopen("sokoban.txt","w");
	for(int i=0;i<10;i++)
	fprintf(out,"%c",name[i]);
	fprintf(out,"\n");
	fprintf(out,"%d\n",n);
	int temp = n;
	for(n; n < 5; n++){
     		for(int i=1 ; i<size[n] ;i ++){
          		for(int j=0 ;j<30 ; j++){
              		fprintf(out,"%c",map[n][i][j]);
                       		  }
               		fprintf(out,"\n");
                     		    }
               		fprintf(out,"\n");}
	n = temp;
	fclose(out);
		}
   case 'f':
	
	break;
  
   void display() // 
   {
     printf("h(왼쪽), j(아래), k(위), l(오른쪽)\n");
     printf("u(undo)\n");
     printf("r(replay)\n");
     printf("n(new)\n");
     printf("e(exit)\n");
     printf("s(save)\n");
     printf("f(file load)\n");
     printf("d(display help\n");
     printf("t(top)\n");
}
}
